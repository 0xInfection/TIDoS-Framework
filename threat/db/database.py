import sqlite3
import os

# This function saves data generated by the modules. Every data-generating module should
# import this function and call it with the following arguments:
#   database = database name in the format :databasename.db". This will be the same
#       throughout the session.
#   module = the name of the top-level module you're in. Can't have spaces or special
#       characters. Should be EXACTLY matching one of the following:
#       "ReconANDOSINT", "ScanANDEnum", "VulnAnalysis", "Exploitation", or "AuxModules"
#   lvl1, lvl2, lvl3 = the names of the next levels of modules, on down to the one you're
#       in. If you don't go all the way down to lvl3, input Null. Can have spaces. Should
#       exactly match the name of the module as written in the menu.
#   data = should be the data generated by the module. It will be unchanged when it is
#       passed in and out of the database.
def save_data(database, module, lvl1, lvl2, lvl3, data):
    connection = sqlite3.connect(database)
    cursor = connection.cursor()
    check_table = 'SELECT name FROM sqlite_master WHERE type=\'table\' AND name=\'{}\''.format(module)
    cursor.execute(check_table)
    checker = cursor.fetchone()
    if checker == None:
        create_table = 'CREATE TABLE {} (\
            id INTEGER PRIMARY KEY, \
            lvl1 text not null, \
            lvl2 text, \
            lvl3 text, \
            number int, \
            data blob);'.format(module)
        cursor.execute(create_table)
        connection.commit()
    check_entries = 'SELECT * FROM {} WHERE number=?'.format(module)
    ctr = 1
    while True:
        cursor.execute(check_entries, [ctr])
        checker = cursor.fetchone()
        if checker == None:
            break
        else:
            ctr += 1
    insert_into_table = 'INSERT INTO {} (lvl1, lvl2, lvl3, number, data) VALUES (?, ?, ?, ?, ?);'.format(module)
    table_entry_parameters = (lvl1, lvl2, lvl3, ctr, data)
    cursor.execute(insert_into_table, table_entry_parameters)
    connection.commit()
    connection.close()

def retrieve_data(database, module, num):
    connection = sqlite3.connect(database)
    cursor = connection.cursor()
    select_from_table = 'SELECT * FROM {} WHERE number={}'.format(module, num)
    cursor.execute(select_from_table)
    returned_data = cursor.fetchall()
    print(returned_data)
    connection.close()

def get_info(database):
    modules = ['ReconANDOSINT', 'ScanANDEnum', 'VulnAnalysis', 'Exploitation', 'AuxModules']
    modules_saved = []
    data_saved = {}
    connection = sqlite3.connect(database)
    cursor = connection.cursor()
    for module in modules:
        check_table = 'SELECT name FROM sqlite_master WHERE type=\'table\' AND name=\'{}\''.format(module)
        cursor.execute(check_table)
        check = cursor.fetchone()
        if check != None:
            modules_saved.append(module)
    for module in modules_saved:
        data_saved[module] = {}

#        for sub in sub_modules:
#            print(sub)
#            select_from_table = 'SELECT data FROM {} WHERE lvl1={}'.format(module, sub)
#            cursor.execute(select_from_table)
#            thingy = cursor.fetchone()
#            if thingy != None:
#                data_saved[module].append(sub)
    print(data_saved)
    connection.close()